---
title: "Chapter 3: Classification"
author: "Jacob Carey"
date: \today
output: pdf_document
---

Here we generate some binomial data and visualize.

```{r}
# libraries
library(ggplot2)
library(mvtnorm)
library(fields)
theme_set(theme_classic())

# generate binomial data for linear model
set.seed(90210)
N <- 500
beta <- 2.5

x <- seq(-1, 1, len=N)
z <- beta * x                       # linear function
p.true <- 1 / (1 + exp(-z))
y <- rbinom(N, 1, p.true)

data <- data.frame(x=x, p=p.true, y=y)

ggplot(data, aes(x, y)) +
    geom_point() +
    geom_line(aes(x=x, y=p))
```

Now we naively use the laplace approximation for the binary GP classifier.

```{r}
# GP classification
K.func <- function(X.p, X.q=NULL) {
    sigma <- exp(-0.5 * rdist(X.p, X.q) ^ 2)
    return(sigma)
}

f <- rep(0, length(x))   # initialize to 0 
K <- K.func(x)           # calcualte K
I <- diag(1, length(x))

# initialize objective function to high value
obj <- 1000
eps <- 1e-6

# repeat until convergence
while (obj > eps) {
    # calculate probability using logistic function
    pi <- as.vector(1 / (1 + exp(-f)))

    # construct W (- Hessian of logistic log likelihood)
    W <- diag(pi * (1 - pi))
    W.sqrt <- sqrt(W)

    # calculate gradient
    grad <- y - pi

    B <- I + W.sqrt %*% K %*% W.sqrt
    L <- t(chol(B))
    b <- W %*% f + grad
    a <- b - backsolve(W.sqrt %*% t(L), forwardsolve(L, W.sqrt %*% K %*% b))
    f <- K %*% a

    # update (works!)
    f <- K %*% solve(I + W %*% K) %*% (W %*% f + grad)


    obj <- (y - as.vector(1 / (1 + exp(-f)))) - K.inv %*% f
    obj <- sum(obj ^ 2)
    message(obj)
}
```

Now write algorithm 3.1 to more efficiently perform the laplace approximation.

```{r}

while (FALSE) {
    # take square root of W for calculating B
    # can just use sqrt since W is diagonal
    W.sqrt <- sqrt(W) 
    B <- diag(1, nrow(K)) + W.sqrt %*% K %*% W.sqrt
    L <- t(chol(B))
    b <- W %*% f + cbind(y - pi)
    a <- b - backsolve(W.sqrt %*% t(L), forwardsolve(L, W.sqrt %*% K %*% b))

    # update f
    f <- K %*% a

    # recalculate objective function
    obj <- -0.5 * t(a) %*% f - log(1 + exp(-y.svm %*% f))
}
```
